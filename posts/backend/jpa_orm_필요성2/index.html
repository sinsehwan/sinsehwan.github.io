<!DOCTYPE html>
<html lang="ko-kr"
  dir="ltr">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="https://sinsehwan.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sinsehwan.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sinsehwan.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://sinsehwan.github.io/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://sinsehwan.github.io/apple-touch-icon.png">

<meta name="description" content="객체 중심 모델과 데이터 중심 모델의 패러다임 차이 - backend"/>


<meta name="fediverse:creator" content="@username@instance.url">


<title>
    
    ORM(JPA)의 필요성 - 2 | Sehwan&#39;s Dev Retrospect
    
</title>

<link rel="canonical" href="https://sinsehwan.github.io/posts/backend/jpa_orm_%ED%95%84%EC%9A%94%EC%84%B12/"/>

<meta property="og:url" content="https://sinsehwan.github.io/posts/backend/jpa_orm_%ED%95%84%EC%9A%94%EC%84%B12/">
  <meta property="og:site_name" content="Sehwan&#39;s Dev Retrospect">
  <meta property="og:title" content="ORM(JPA)의 필요성 - 2">
  <meta property="og:description" content="객체 중심 모델과 데이터 중심 모델의 패러다임 차이 - backend">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-10-10T00:00:00+00:00">
    <meta property="article:tag" content="Backend">
    <meta property="article:tag" content="Java">












<link rel="stylesheet" href="/assets/combined.min.fc5a44152c30c21bef13cba5205c8eddd1f54213723dfec49cb38631ef05a293.css" media="all">




      <script async src="https://www.googletagmanager.com/gtag/js?id=G-xxxxxxxxx"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-xxxxxxxxx');
        }
      </script>











    




</head>







<body class="dark">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="https://sinsehwan.github.io/">Sehwan&#39;s Dev Retrospect</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/tags/" >
                /tags
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/posts/">Posts</a><span class="breadcrumbs-separator">/</span>
        <a href="/posts/backend/jpa_orm_%ED%95%84%EC%9A%94%EC%84%B12/">ORM(JPA)의 필요성 - 2</a></div>


<div  class="autonumber" >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">ORM(JPA)의 필요성 - 2</h1>
        <p class="single-summary">객체 중심 모델과 데이터 중심 모델의 패러다임 차이</p>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="author">Sin SeHwan </p>
            
            <p class="single-date">
              <time datetime="2025-10-10T00:00:00&#43;00:00">October 10, 2025</time>
              &nbsp; · &nbsp;3 min read
            </p>
          </div>
        </div>
        
    </header>    
        <div class="single-tags"><span>
                  <a href="https://sinsehwan.github.io/tags/backend/">#Backend</a>
                </span><span>
                  <a href="https://sinsehwan.github.io/tags/java/">#Java</a>
                </span>
        </div>
      <aside class="toc">
        <p><strong>Table of contents</strong></p>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#객체-중심-모델과-데이터-중심-모델의-패러다임-차이">객체 중심 모델과 데이터 중심 모델의 패러다임 차이</a>
      <ul>
        <li><a href="#객체지향">객체지향</a></li>
        <li><a href="#rdbms">RDBMS</a></li>
      </ul>
    </li>
    <li><a href="#패러다임-차이">패러다임 차이</a>
      <ul>
        <li><a href="#상속">상속</a></li>
        <li><a href="#연관관계">연관관계</a></li>
        <li><a href="#객체-그래프-탐색">객체 그래프 탐색</a></li>
      </ul>
    </li>
    <li><a href="#요약">요약</a></li>
  </ul>
</nav>
      </aside>
    
    <div class="single-content">
      <h1 class="heading" id="ormjpa의-필요성---2">
  ORM(JPA)의 필요성 - 2
  <a class="anchor" href="#ormjpa%ec%9d%98-%ed%95%84%ec%9a%94%ec%84%b1---2">#</a>
</h1>
<blockquote>
<p>ORM 방식을 왜 쓰는지, 썼을 때 어떠한 장점이 있는지 구체적으로 살펴봅시다.</p></blockquote>
<h2 class="heading" id="객체-중심-모델과-데이터-중심-모델의-패러다임-차이">
  객체 중심 모델과 데이터 중심 모델의 패러다임 차이
  <a class="anchor" href="#%ea%b0%9d%ec%b2%b4-%ec%a4%91%ec%8b%ac-%eb%aa%a8%eb%8d%b8%ea%b3%bc-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a4%91%ec%8b%ac-%eb%aa%a8%eb%8d%b8%ec%9d%98-%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84-%ec%b0%a8%ec%9d%b4">#</a>
</h2>
<p>객체 중심 모델은 객체지향 언어로 개발된 애플리케이션으로, 데이터 중심 모델은 RDBMS로 생각할 수 있습니다.</p>
<h3 class="heading" id="객체지향">
  객체지향
  <a class="anchor" href="#%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5">#</a>
</h3>
<ul>
<li>
<p>추상화, 캡슐화, 상속, 다형성을 사용해서 각 모듈의 의존성을 줄이고자 합니다.</p>
</li>
<li>
<p>속성(필드)와 기능(메소드)를 정의해서 외부에서 세부 동작을 직접 제어하기보다는 객체에게 작업을 시킨다는 관점으로 설계합니다.</p>
</li>
</ul>
<h3 class="heading" id="rdbms">
  RDBMS
  <a class="anchor" href="#rdbms">#</a>
</h3>
<ul>
<li>
<p>데이터 중심으로 구조화돼 있고, 집합적인 사고를 요구합니다.</p>
</li>
<li>
<p>객체지향 개념에서의 추상화, 상속, 다형성 등의 개념이 존재하지 않습니다.</p>
</li>
</ul>
<h2 class="heading" id="패러다임-차이">
  패러다임 차이
  <a class="anchor" href="#%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84-%ec%b0%a8%ec%9d%b4">#</a>
</h2>
<p>객체 중심 모델(객체지향)과 데이터 중심 모델(RDBMS)은 다음과 같은 부분에서 패러다임이 다릅니다.</p>
<h3 class="heading" id="상속">
  상속
  <a class="anchor" href="#%ec%83%81%ec%86%8d">#</a>
</h3>
<p>다음과 같은 구조에서 Admin, User 저장 시 sql문을 어떻게 정의해야 할까요?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Member</span> {
</span></span><span style="display:flex;"><span>    Long memberId;
</span></span><span style="display:flex;"><span>    String name;
</span></span><span style="display:flex;"><span>    String tel;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Admin</span> <span style="color:#8be9fd;font-style:italic">extends</span> Member {
</span></span><span style="display:flex;"><span>    String level;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">User</span> <span style="color:#8be9fd;font-style:italic">extends</span> Member {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> points;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>DB 구조는 다음과 같이 구성할 수 있습니다.</li>
</ul>
<p>











<figure class="">

    <div class="img-container" style="--w: 1123; --h: 790;">
        <img loading="lazy" alt="상속_erd" src="/posts/backend/jpa_orm_%ED%95%84%EC%9A%94%EC%84%B12/images/%EC%83%81%EC%86%8D_erd.png" width="1123" height="790">
    </div>

    
</figure>
</p>
<p>이 상황에서 Admin 객체를 저장하려면 객체를 분리해서 SQL문을 두 번 수행해야 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> MEMBER ...
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">INSERT</span> <span style="color:#ff79c6">INTO</span> <span style="color:#ff79c6">ADMIN</span> ...
</span></span></code></pre></div><p>즉, JDBC API를 사용해서 상속된 객체를 저장하려면 부모 객체에서 부모 데이터만 꺼내서 INSERT문을 하나 작성하고, 자식 객체에서 자식 데이터만 꺼내서 INSERT문을 따로 작성해야 합니다.</p>
<p>조회 과정에서도 SELECT 문을 두 번 따로 수행해서 객체를 조합해야겠죠.</p>
<p>자바 컬렉션에서는 다음과 같은 방식으로 단순하게 끝낼 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ArrayList<span style="color:#ff79c6">&lt;</span>Member<span style="color:#ff79c6">&gt;</span> list <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> ArrayList<span style="color:#ff79c6">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>list.<span style="color:#50fa7b">add</span>(admin);
</span></span></code></pre></div><p>이와 비교해보면 패러다임 불일치로 인한 비용이 높다는 것을 알 수 있습니다.</p>
<h3 class="heading" id="연관관계">
  연관관계
  <a class="anchor" href="#%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84">#</a>
</h3>
<ul>
<li>객체는 참조를 통해 연관된 객체를 조회할 수 있습니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Member</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> Long memberId;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> String name;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> String tel;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> Team team; <span style="color:#6272a4">// 추가</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">getTeam</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">this</span>.<span style="color:#50fa7b">team</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Team</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> Long teamId;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> String teamName;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위와 같은 예시에서 Member에 저장된 Team을 member.getTeam()형식으로 가져올 수 있습니다. 단, team객체를 통해 member객체를 조회할 수는 없습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> M.<span style="color:#ff79c6">*</span>, T.<span style="color:#ff79c6">*</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">FROM</span> Member M
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">JOIN</span> Team T <span style="color:#ff79c6">ON</span> M.team_id <span style="color:#ff79c6">=</span> T.team_id
</span></span></code></pre></div><ul>
<li>테이블은 외래키(FK)를 사용해서 다른 테이블과 연관관계를 통해 join을 수행함으로써 연관된 테이블을 조회합니다.</li>
</ul>
<p>위의 두 가지 방식에서 달라지는 부분은 객체에서는 team을 참조로 다루고, RDBMS에는 team의 id를 FK로 설정해서 관리합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Member</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> Long memberId;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> String name;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> String tel;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> Long teamId; <span style="color:#6272a4">// 추가</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">getTeam</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// ??</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Team</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> Long teamId;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">private</span> String teamName;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>그러면 객체에서도 id를 저장하면 되는 것이 아닌가 생각할 수 있지만, 객체는 JOIN연산이 기본적으로 존재하지 않습니다. 또한 그렇게 진행하면 객체의 참조 기능을 사용하지 못하게 되기에 객체지향의 특성을 잃어버리게 됩니다.</p>
<p>결국 개발자가 참조 방식 접근, FK 기반 접근 사이의 변환 로직을 구현해야 한다는 문제가 생깁니다.</p>
<h3 class="heading" id="객체-그래프-탐색">
  객체 그래프 탐색
  <a class="anchor" href="#%ea%b0%9d%ec%b2%b4-%ea%b7%b8%eb%9e%98%ed%94%84-%ed%83%90%ec%83%89">#</a>
</h3>
<p>객체에서 참조를 사용해서 연관된 객체를 찾는 것을 객체 그래프 탐색이라고 합니다.</p>
<pre tabindex="0"><code>Member ──&lt; Team
   │
   └──&lt; Diary ──&lt; Music ──&lt; Album ──&lt; Artist ...
</code></pre><p>우리는 Member를 통해 객체 그래프를 탐색하길 원합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>member.<span style="color:#50fa7b">getDiary</span>().<span style="color:#50fa7b">getMusic</span>().<span style="color:#50fa7b">getAlbum</span>()  ...
</span></span></code></pre></div><p>만약 다음과 같은 SQL문으로 Member를 조회한다면 어떨까요?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> M.<span style="color:#ff79c6">*</span>, D.<span style="color:#ff79c6">*</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">FROM</span> Member M
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">JOIN</span> Diary D
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ON</span> M.diary_id <span style="color:#ff79c6">=</span> D.diary_id
</span></span></code></pre></div><p>getDiary()까지는 정상적으로 수행되겠지만, getMusic에서 NullPointerException이 발생하게 됩니다. Music 테이블을 JOIN한 적이 없기 때문이죠.</p>
<p>즉, SQL을 직접 다루면 객체 그래프 탐색 범위를 미리 정해줘야 한다는 문제가 발생합니다.</p>
<p>모든 연관 객체를 조회하는 것은 비용이 비싸기 때문에 결국 Member 조회 메소드를 상황에 따라 여러 벌 만들어서 사용해야 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>memberRepository.<span style="color:#50fa7b">getMember</span>();
</span></span><span style="display:flex;"><span>memberRepository.<span style="color:#50fa7b">getMemberWithDiary</span>();
</span></span><span style="display:flex;"><span>memberRepository.<span style="color:#50fa7b">getMemberWithDiaryWithMusic</span>();
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>JPA에서는 지연 로딩이라는 기능을 통해 해당 문제를 해결합니다.</p>
<h2 class="heading" id="요약">
  요약
  <a class="anchor" href="#%ec%9a%94%ec%95%bd">#</a>
</h2>
<p>상속, 연관관계, 객체 그래프 탐색 등의 객체지향의 전형적인 특성이자 장점을 DB 단에서 수행하기 어렵다는 문제가 있습니다.</p>
<p>패러다임 차이로 인해 발생하는 DB와 객체지향 설계 사이의 간극을 좁히기 위해 ORM(Object Relational Mapping)이 등장하게 되었습니다.</p>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/cloud/msa2k8s/">
                        MSA 애플리케이션을 쿠버네티스로 배포하기 - k8s
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/backend/jpa_orm_%ED%95%84%EC%9A%94%EC%84%B11/">
                        ORM(JPA)의 필요성 - 1
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
